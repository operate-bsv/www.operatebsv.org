(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{619:function(t,a,n){"use strict";n.r(a);var e=n(41),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("Ops are written using the programming language Lua - a very simple language with few concepts. The standard library is useful, but certainly minimal - it's fair to say there are no bells and whistles with Lua.")]),t._v(" "),n("p",[t._v("One feature that Lua lacks is a cryptographic library. For a Bitcoin tool like Operate, this is essential so we have added a "),n("code",[t._v("crypto")]),t._v(" module jam-packed with common crypto functions. How did we do this?")]),t._v(" "),n("p",[t._v("What we definitely didn't do is develop an entirely new and native crypto module written in Lua. No, for the sake of our own sanity we did things the lazy way. We created a way to extend Lua with modules and functions implemented in the host system - in this case Elixir. That means every time you call a crypto function in an Op, under the hood it is actually being handled by Erlang's robust and battle-tested standard crypto library.")]),t._v(" "),n("h2",{attrs:{id:"anatomy-of-an-extension"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#anatomy-of-an-extension"}},[t._v("#")]),t._v(" Anatomy of an extension")]),t._v(" "),n("p",[t._v("The best way to understand how extensions work is to look at some code:")]),t._v(" "),n("div",{staticClass:"language-elixir extra-class"},[n("pre",{pre:!0,attrs:{class:"language-elixir"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("defmodule")]),t._v(" Operate"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Extension"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("JSON "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token attribute variable"}},[t._v("@moduledoc")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"""\n  Extends the VM state with functions for encoding and decoding JSON.\n  """')]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" Operate"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Extension\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alias")]),t._v(" Operate"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VM\n\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" extend"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n    vm\n    "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|>")]),t._v(" VM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("set!"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"json"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|>")]),t._v(" VM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("set_function!"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"json.decode"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" _vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" apply"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__MODULE__"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token atom symbol"}},[t._v(":decode")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|>")]),t._v(" VM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("set_function!"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"json.encode"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" _vm"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" apply"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__MODULE__"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token atom symbol"}},[t._v(":encode")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token attribute variable"}},[t._v("@doc")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Decodes the given JSON string."')]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" decode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("do:")]),t._v(" Jason"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("decode!"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token attribute variable"}},[t._v("@doc")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Encodes the given value into a JSON string."')]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" encode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("do:")]),t._v(" VM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("decode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|>")]),t._v(" Jason"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("encode!\n  \n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n")])])]),n("p",[t._v("The above module is an example of an extension. The "),n("code",[t._v("extend/1")]),t._v(" function takes the "),n("code",[t._v("vm")]),t._v(" and defines a table with the variable name "),n("code",[t._v("json")]),t._v(" and attaches two functions - "),n("code",[t._v("encode()")]),t._v(" and "),n("code",[t._v("decode()")]),t._v(" - which are handled by a function in Elixr.")]),t._v(" "),n("p",[t._v("Now within your Ops you can encode a table into a JSON string, and no-one needs to know that Lua is being lazy and passing the job to Elixir to handle.")]),t._v(" "),n("div",{staticClass:"language-lua extra-class"},[n("pre",{pre:!0,attrs:{class:"language-lua"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("local")]),t._v(" data "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  foo "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'bar'")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\njson"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("encode")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('-- => "{\\"foo\\":\\"bar\\"}"')]),t._v("\n")])])]),n("p",[t._v("The Operate Agent has the following extensions enabled by default:")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://github.com/operate-bsv/op_agent/blob/master/lib/operate/vm/extension/agent.ex",target:"_blank",rel:"noopener"}},[n("code",[t._v("agent")]),n("OutboundLink")],1),t._v(" - functions for accessing the agent to load and run other transactions.")]),t._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/operate-bsv/op_agent/blob/master/lib/operate/vm/extension/base.ex",target:"_blank",rel:"noopener"}},[n("code",[t._v("base")]),n("OutboundLink")],1),t._v(" - common functions for converting strings to and from hex and base64 encodings.")]),t._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/operate-bsv/op_agent/blob/master/lib/operate/vm/extension/context.ex",target:"_blank",rel:"noopener"}},[n("code",[t._v("context")]),n("OutboundLink")],1),t._v(" - functions for accessing the transaction context (other inputs and outputs).")]),t._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/operate-bsv/op_agent/blob/master/lib/operate/vm/extension/crypto.ex",target:"_blank",rel:"noopener"}},[n("code",[t._v("crypto")]),n("OutboundLink")],1),t._v(" - extends the VM with common crypto functions.")]),t._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/operate-bsv/op_agent/blob/master/lib/operate/vm/extension/json.ex",target:"_blank",rel:"noopener"}},[n("code",[t._v("json")]),n("OutboundLink")],1),t._v(" - functions for encoding and decoding JSON.")])]),t._v(" "),n("h2",{attrs:{id:"taking-things-further"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#taking-things-further"}},[t._v("#")]),t._v(" Taking things further")]),t._v(" "),n("p",[t._v("Now that you understand what an extension is, and how easy it is to write one, things can get interesting because you can extend Operate to do just about anything you can imagine. Now Bitcoin transactions can talk directly to functions inside your application... think about what kind of use cases that can enable!")]),t._v(" "),n("p",[t._v("You can create Bitcoin transactions that trigger off-chain processes such as image or video processing. How about a transaction containing an HTML payload that with the correct payment triggers an offchain process to convert the document into a PDF?")]),t._v(" "),n("p",[t._v("There are all sorts of microservices that can now be built on top of Bitcoin, and all sorts of creative ways Bitcoin can tightly integrate with your application or product.")]),t._v(" "),n("p",[t._v("It's time to build!")])])}),[],!1,null,null,null);a.default=s.exports}}]);